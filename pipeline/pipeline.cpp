#include "pipeline.h"

#include "../ecs.h"
#include "../storage/hierarchical_storage.h"
#include "../world/world.h"

Pipeline::Pipeline() {
}

// Unset the macro defined into the `pipeline.h` so to properly point the method
// definition.
#undef add_temporary_system
void Pipeline::add_temporary_system(func_temporary_system_execute p_func_get_exe_info) {
	temporary_systems_exe.push_back(p_func_get_exe_info);
}

void Pipeline::add_registered_temporary_system(godex::system_id p_id) {
	add_temporary_system(ECS::get_func_temporary_system_exe(p_id));
}

// Unset the macro defined into the `pipeline.h` so to properly point the method
// definition.
#undef add_system
uint32_t Pipeline::add_system(func_get_system_exe_info p_func_get_exe_info) {
#ifdef DEBUG_ENABLED
	// This is automated by the `add_system` macro or by
	// `ECS::register_system` macro, so is never supposed to happen.
	CRASH_COND_MSG(p_func_get_exe_info == nullptr, "The passed system constructor can't be nullptr at this point.");
	// Using crash cond because pipeline composition is not directly exposed
	// to the user.
	CRASH_COND_MSG(is_ready(), "The pipeline is ready, you can't modify it.");
#endif
	const uint32_t in_pipeline_id = systems_info.size();
	systems_info.push_back(p_func_get_exe_info);
	return in_pipeline_id;
}

uint32_t Pipeline::add_registered_system(godex::system_id p_id) {
	const uint32_t in_pipeline_id = add_system(ECS::get_func_system_exe_info(p_id));
	if (ECS::is_system_dispatcher(p_id)) {
		system_dispatchers.push_back(in_pipeline_id);
	}
	return in_pipeline_id;
}

void Pipeline::build() {
#ifdef DEBUG_ENABLED
	CRASH_COND_MSG(ready, "You can't build a pipeline twice.");
#endif
	ready = true;

	systems_exe.reserve(systems_info.size());

	SystemExeInfo info;
	for (uint32_t i = 0; i < systems_info.size(); i += 1) {
		info.clear();
		systems_info[i](info);

		ERR_CONTINUE_MSG(info.valid == false, "[FATAL][FATAL][FATAL][PIPELINE-FATAL] The system with index: " + itos(i) + " is invalid. Excluded from pipeline.");

#ifdef DEBUG_ENABLED
		// This is automated by the `add_system` macro or by
		// `ECS::register_system` macro, so is never supposed to happen.
		CRASH_COND_MSG(info.system_func == nullptr, "At this point `info.system_func` is supposed to be not null. To add a system use the following syntax: `add_system(function_name);` or use the `ECS` class to get the `SystemExeInfo` if it's a registered system.");
#endif

		systems_exe.resize(systems_exe.size() + 1);
		ExecutionData &ed = systems_exe[systems_exe.size() - 1];

		ed.exe = info.system_func;

		const bool is_system_dispatcher = system_dispatchers.find(i) != -1;

		if (is_system_dispatcher == false) {
			// Take the events that are generated by this pipeline
			// (no sub pipelines).
			for (uint32_t c = 0; c < info.mutable_components_storage.size(); c += 1) {
				if (ECS::is_component_events(info.mutable_components_storage[c])) {
					// Make sure it's unique
					if (event_generator.find(info.mutable_components_storage[c]) == -1) {
						event_generator.push_back(info.mutable_components_storage[c]);
					}
				}
			}

			// Mark as flush, the storages that need to be flushed at the end
			// of the `System`.
			for (uint32_t c = 0; c < info.mutable_components.size(); c += 1) {
				if (ECS::storage_notify_release_write(info.mutable_components[c])) {
					ed.notify_list_release_write.push_back(info.mutable_components[c]);
				}
			}
			for (uint32_t c = 0; c < info.mutable_components_storage.size(); c += 1) {
				if (ECS::storage_notify_release_write(info.mutable_components_storage[c])) {
					if (ed.notify_list_release_write.find(info.mutable_components_storage[c]) == -1) {
						ed.notify_list_release_write.push_back(info.mutable_components_storage[c]);
					}
				}
			}

			// If set: make sure that the `Child` storage (so the `Hierarchy`)
			// is flushed first.
			const int64_t child_index = ed.notify_list_release_write.find(Child::get_component_id());
			if (child_index != -1) {
				SWAP(ed.notify_list_release_write[child_index], ed.notify_list_release_write[0]);
				CRASH_COND(ed.notify_list_release_write[0] != Child::get_component_id());
			}
		}
	}
}

bool Pipeline::is_ready() const {
	return ready;
}

void Pipeline::get_systems_dependencies(SystemExeInfo &p_info) const {
	SystemExeInfo other_info;
	for (uint32_t i = 0; i < systems_info.size(); i += 1) {
		other_info.clear();

		systems_info[i](other_info);

		// Handles the Components.
		for (uint32_t t = 0; t < other_info.immutable_components.size(); t += 1) {
			const godex::component_id id = other_info.immutable_components[t];

			const bool is_unique = p_info.immutable_components.find(id) == -1;
			if (is_unique) {
				p_info.immutable_components.push_back(id);
			}
		}

		for (uint32_t t = 0; t < other_info.mutable_components.size(); t += 1) {
			const godex::component_id id = other_info.mutable_components[t];

			const bool is_unique = p_info.mutable_components.find(id) == -1;
			if (is_unique) {
				p_info.mutable_components.push_back(id);
			}
		}

		// Handles the Component storages.
		for (uint32_t t = 0; t < other_info.mutable_components_storage.size(); t += 1) {
			const godex::component_id id = other_info.mutable_components_storage[t];

			const bool is_unique = p_info.mutable_components_storage.find(id) == -1;
			if (is_unique) {
				p_info.mutable_components_storage.push_back(id);
			}
		}

		// Handles the Databags.
		for (uint32_t t = 0; t < other_info.immutable_databags.size(); t += 1) {
			const godex::databag_id id = other_info.immutable_databags[t];

			const bool is_unique = p_info.immutable_databags.find(id) == -1;
			if (is_unique) {
				p_info.immutable_databags.push_back(id);
			}
		}

		for (uint32_t t = 0; t < other_info.mutable_databags.size(); t += 1) {
			const godex::databag_id id = other_info.mutable_databags[t];

			const bool is_unique = p_info.mutable_databags.find(id) == -1;
			if (is_unique) {
				p_info.mutable_databags.push_back(id);
			}
		}
	}
}

void Pipeline::reset() {
	systems_info.clear();
	systems_exe.clear();
	ready = false;
}

void Pipeline::prepare(World *p_world) {
	// Crete components and databags storages.
	SystemExeInfo info;
	for (uint32_t i = 0; i < systems_info.size(); i += 1) {
		info.clear();
		systems_info[i](info);

		// Create components.
		for (uint32_t t = 0; t < info.immutable_components.size(); t += 1) {
			const godex::component_id id = info.immutable_components[t];
			p_world->create_storage(id);
		}

		for (uint32_t t = 0; t < info.mutable_components.size(); t += 1) {
			const godex::component_id id = info.mutable_components[t];
			p_world->create_storage(id);
		}

		for (uint32_t t = 0; t < info.mutable_components_storage.size(); t += 1) {
			const godex::component_id id = info.mutable_components_storage[t];
			p_world->create_storage(id);
		}

		// Create databags.
		for (uint32_t t = 0; t < info.immutable_databags.size(); t += 1) {
			const godex::databag_id id = info.immutable_databags[t];
			p_world->create_databag(id);
		}

		for (uint32_t t = 0; t < info.mutable_databags.size(); t += 1) {
			const godex::databag_id id = info.mutable_databags[t];
			p_world->create_databag(id);
		}
	}
}

void Pipeline::dispatch(World *p_world) {
#ifdef DEBUG_ENABLED
	CRASH_COND_MSG(ready == false, "You can't dispatch a pipeline which is not yet builded. Please call `build`.");
#endif

	p_world->is_dispatching_in_progress = true;

	Hierarchy *hierarchy = static_cast<Hierarchy *>(p_world->get_storage<Child>());
	if (hierarchy) {
		// Flush the hierarchy.
		hierarchy->flush_hierarchy_changes();
	}

	// Process the `TemporarySystem`, if any.
	for (int i = 0; i < int(temporary_systems_exe.size()); i += 1) {
		if (temporary_systems_exe[i](p_world)) {
			temporary_systems_exe.remove(i);
			i -= 1;
		}
	}

	// Dispatch the `System`s.
	for (uint32_t i = 0; i < systems_exe.size(); i += 1) {
		const ExecutionData &ed = systems_exe[i];
		ed.exe(p_world);

		// Notify the `System` released the storage.
		for (uint32_t f = 0; f < ed.notify_list_release_write.size(); f += 1) {
			p_world->get_storage(ed.notify_list_release_write[f])->on_system_release();
		}
	}

	// Clear any generated component storages.
	for (uint32_t c = 0; c < event_generator.size(); c += 1) {
		p_world->get_storage(event_generator[c])->clear();
	}

	p_world->is_dispatching_in_progress = false;
}
